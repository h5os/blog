<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>寻求前后端一体化开发的最佳实践</title>
<meta name="keywords" content="frontend,backend,best-practice">
</head>
<body>
<div>
<h1 id="-">﻿寻求前后端一体化开发的最佳实践</h1>
<ul>
<li><a href="#introduce">背景介绍</a></li>
<li><a href="#tech_dir">认准趋势</a></li>
<li><a href="#microservice">适应微服务架构</a></li>
<li><a href="#meteor">借鉴 Meteor</a></li>
<li><a href="#dev_ops">分阶段迭代</a></li>
<li><a href="#join_us">如何参与</a></li>
</ul>
<hr>
<p><a name="introduce"></a>&nbsp;</p>
<h2 id="-">背景介绍</h2>
<p>刚才在 github 上注册了 best-practice 组织及 best-js 用户，很奇怪这么好的名字居然还没被人注册。
注册 best-practice 是想借助 <a href="https://pages.github.com/">github pages</a>
建立一个专题博客，该专题聚焦于：<strong>寻求 “前后端一体化开发” 的最佳实践</strong>。</p>
<p>我尝试用已确定的事情，细化描述这个目标：前后端软件开发采用 javascript
一种语言，针对主流的Web/Native开发场景，寻找一种高效的、最佳开发模式，
这种开发模式将现有 html5/css3，javascript，nodejs，react
等技术的优势能很好的捏合在一起，立足于Web开发，并借助第3语言（类JS）
让Web开发能很好延伸到Native开发，让这两者向一体化方向靠拢。</p>
<p>寻找最佳实践是 1)确定趋势，2)试验各种做法找出最佳，3)补上市场缺位 的过程，
必然要坚持很长一段时间。为得到更多业界高手的支持，我在 github
建此专题，尝试拿实际项目 <strong>演化、推进</strong> 最佳实践。
这个实际项目就<strong>拼文系统</strong>（<a target="_blank" href="http://www.pinp.me/www/www/">点这里进 PINP 网站</a>），
简单来讲拼文就是 web 化的 <strong>PPT</strong> 与 <strong>Blog</strong>，它有一套完善的在线编辑器与离线编辑器，
有云盘支持系统，以文档分享为基础还形成一个社交分享网络。</p>
<p>OK，本文就是一篇博客风格的<strong>拼文</strong>，等你了解多些，会赞叹它的丰富表现力与可拓展能力的。
PINP直接解决在 github 上编写设计文档不方便的痛点，比如绘图、制表、嵌入演示胶片等。
因为 github pages 是免费的，我们用它构造的拼文系统也将免费，而且在 github 上开源。</p>
<hr>
<p><a name="tech_dir"></a>&nbsp;</p>
<h2 id="-">认准趋势</h2>
<p>JS是一门神奇语言，这么多年没被干掉，而且经久不衰，越来越活跃。
我将 <strong>JS化</strong> 看作“前后端一体化开发”必由途径，<strong>未来未必是JS，
但必然类JS</strong>。我们基于现实作选择：先顺从 javascript 看它能演进到什么程度，
之后再看它还有哪些缺陷，换个方向还能走多远。</p>
<p>不要告诉我 C# 或 java 也可以成为一体化开发的最佳实践，最佳只一个，
成为最佳，那它就是世界上最好的，剩下的都是烂货，嘿，我不是乔布斯，
不提那个烂苹果，只针对“前后端一体化开发”的目标场景，在特定场景下区分好赖。
所以，将 JS 作为前后端一体化开发语言，是我们的前置条件，不再调研论证，
如果您对此有疑虑，恐怕今后本专题不少文章都会让你失望。</p>
<p>之前 Angular 刚兴起时，我专门学了学，刚入门就觉得白浪费时间了，
有朋友问我 Angular 值不值得入手，我说，JS领域许多东西等你学会就过时了，
很不幸 Angular 就是这类东西，果然没出五个月，Angular2 就宣布不兼容之前版本，
即便如此，Angular2 仍不值得一学，原因只一条：它不是趋势。</p>
<p>所有前端框架都面临模板化与反模板的两难困境，简单场景下模板化编程一点都没问题，
但对于复杂场景，当界面元素随状态条件大幅变化，高度动态时，纯粹借助模板以数据驱动方式编程，
肯定力不从心，有时你恨不得抛弃所有模板的约束，写几行代码穿越过去。
所有 MVVM 模型中 VM 的表现力，都受一个天花板约束，触顶了，但仍不够用，
这是DOM的组织方式，它的事件机制决定的，属天然限制。Angular 遭遇天花板没啥办法，
react 则以编程的方式操控模板，容易克服这类问题。另外，在 Web 开发与 Native 开发的交汇口，
需要虚拟 DOM 这么一层东西，react 设计很有前瞻性，反映前端开发的发展趋势。
当然，react 也有明显缺点，比如模板混在代码中用，乱糟糟的，不过，这不是本质性缺陷，
可以想办法克服（或缓解）。</p>
<p>在探索最佳研发实践时，非常强调<strong>认准趋势</strong>，一方面这个领域变化太快，
每隔一两天，都有新东西冒出，许多还是重量级的、很有用的。另一方面，
JS没太多范式约束，很适合造轮子，不加判断就投身进去，你的精力很快会被淹没。
前阵子我看过一个视频，青云一位主管大谈计算域与存储域融合的好处，
听起来很有道理，但实际既非主流也逆潮流，能节约硬件投资，但整个方向错了，
计算域与存储域分离是大势，而且计算域自身还在向更小的粒度分离。
我们寻求最佳实践时，只认主流、顺应趋势，世界这么大，不必面面俱到，把主流支持好就够了。</p>
<hr>
<p><a name="microservice"></a>&nbsp;</p>
<h2 id="-">适应微服务架构</h2>
<p>微服务已成发展趋势，现在应该比较清晰了，Docker、MicroServices、Mesos
等技术相伴兴起，合起来反映一种趋势：CaaS（Container as a Service）
在 IaaS 与 PaaS 两者之间破壳而出，分别侵占两者一些地盘，尤其对于 PaaS,
CaaS 简直为颠覆 PaaS 而生的。传统的 PaaS 是一项很贵的技术，只有大公司玩得起，
因为借助一门或多门语言，构造沙箱服务没那么容易，但 PaaS 又是广泛存在需求，
尤其对垂直领域软件商，谁不希望自己的服务能快速二次开发，从容与其它系统对接？
但 PaaS 太贵又不规范，是个大障碍，这时 CaaS 横空出世，在更低维度提供标准接口，
解决了这些问题。</p>
<p>有了 CaaS 谁都可以做 PaaS 发行商，即使独立软件开发者也做得到，台阶很低。
这种变化必然对云服务生态、前后端开发方式等产生深远影响，以前我曾用一个词
<strong>Multi-Vendor</strong> 概括业务层面发生的变化，CaaS 是技术层面的词汇，
技术与业务层面的变迁，都反映了互联网深入发展带来的进一步 <strong>去中心化</strong> 的趋势。</p>
<p>我们强调前后端一体化开发，后端在适应微服务方面，业界尚在起步阶段，
没多少可参考的东西，要靠自己动手试验。</p>
<hr>
<p><a name="meteor"></a>&nbsp;</p>
<h2 id="-meteor">借鉴 Meteor</h2>
<p>Meteor用JS统一支持服务侧与客户侧开发，契合我们的理念，但不考虑基于 Meteor
做扩展，主要是需要变动的地方很多，DDP不错，借用过来。Meteor 适应多种框架，
是一种胶水，但我们只取最佳一种，用到的技术要深挖，这时“广泛适应性”
不是什么好事，成为负担了。</p>
<p>相对Meteor，服务侧变化会很大（大到重用Meteor的价值可以忽略了），
导致变化主要因素有：</p>
<ol>
<li><p>适应微服务架框带来变化<br>大应用要适合分离出若干单体应用，有api网关，支持服务发现、状态维护等机制。</p>
</li>
<li><p>NoSql数据库接口，应独立出一层<br>用一种形式化描述表达数据库操作，形式化描述方法应与编程语言很好融合，
就像当前各云计算厂商用 Python 封装的普遍做法：表操作与记录操作用字典接口，
查询遍历融入 for 语句，这让数据库相关的编程变简单。
使用形式化描述还有另一个好处：方便兼容不同类型数据库。</p>
</li>
<li><p>支持主流厂商的云计算环境</p>
</li>
</ol>
<hr>
<p><a name="dev_ops"></a>&nbsp;</p>
<h2 id="-">分阶段迭代</h2>
<p>我计划用“拼文系统”探索前后端最佳实践，分阶段进行，各阶段都有实物交付，
交付件都是立即投入使用的东西，形成正向循环迭代。</p>
<p>交付件有两类，一类正式产品，另一类是过程文档，包括调研分析的文档，过程讨论，
概略设计文档等。过程文档在 best-practice 博客公开，
<a target="_blank" href="http://best-practice.github.io/www/">点这里打开</a>，
不过，这个博客当前还是初始页，计划经过两轮迭代，把界面做完整。</p>
<p>我们采用类似github的做法，github.com 是主业务（源码托管）系统，github.io 是静态网页系统，
各个被托管项目的 gh-pages 分支，被 github.io 解析为静态网页。www.pinp.me 是主业务（拼文）
系统，pinp.io 则是拼文的静态页系统，实际不止是静态页，以后逐渐增加“动态服务”托管，
但就静态页系统而言，提供功能基本与 github.io 等价。</p>
<p>本博客发布之时，就是“探索前后端一体化开发最佳实践”的迭代正式启动时刻，迭代划分很多阶段，
但各阶段不指定终止日期，目标完成（或中间取消了）阶段性工作自然结束。在每个阶段启动时刻，
都先定义一张 Todo list，执行过程中将随时更新 Todo list，外部人员主要通过查看 To list
及公开的博客文章，来获得项目进展信息，项目成员则主要通过即时通信群进行日常沟通。</p>
<p>探索最佳实践 之 路标规划一：在 github 上建立一套博客系统。</p>
<p>工作目标：支持在 Windows 客户端编写博客（markdown格式、slide演示胶片格式），用 git
命令行发布到 github.io，可通过访问 http://<username>.github.io/ 在线浏览指定用户的博客主页。
各博客主页支持如下功能：</p>
<ol>
<li>查看作者最近发布的文章</li>
<li>每篇文章都可点赞，允许评论</li>
<li>如果访问者已开通 pinp.me 帐号，他还可收藏 github 上别人发布的拼文</li>
<li>提供文档聚合功能，发布博客时可指定文档的 keywords 及所属话题，访问博客时，
相关文章自动被推荐。</li>
<li>支持话题、子话题定义，同一话题的博客（分散在多个作者名下）可拎到列表供集中查阅。</li>
</ol>
<p>该路标规划下的第一阶段迭代，计划完成在 Windows 客户端可发布博客到 github.io，
第二阶段的迭代，则为博客再增加动态服务功能（点赞、评论等）。</p>
<p>当 github 上的博客系统建起来后，我们开启其它路标规划，比如，探索最佳实践 之 路标规划二：
试验 react/nodeJS/docker 最简系统。（注：这项是暂定的）</p>
<hr>
<p><a name="join_us"></a>&nbsp;</p>
<h2 id="-">如何参与？</h2>
<p>欢迎大家以各种形式参与到 <strong>寻求前后端一体化开发的最佳实践</strong> 的活动中来。包括：</p>
<ol>
<li><p>只当路人甲，围观看热闹<br>如果觉得有趣，或有用，顺手为我们的开放项目加个星吧，相关项目在如下几个主页下：  </p>
<ul>
<li><a href="https://github.com/pinp">拼文开源项目</a></li>
<li><a href="https://github.com/best-practice">寻求最佳实践</a></li>
</ul>
</li>
<li><p>准备在 github 上写拼文<br>等我们完成路标规划一的第1次迭代后，放开给大家使用，
现在访问 <a target="_blank" href="http://best-practice.github.io/www/">本博客首页</a> 看到的是初始页面，
证明我们方案是否可行用的。就绪后，这个首页下会有文章介绍如何在 github 搭建拼文博客。</p>
</li>
<li><p>对所探索的主题感兴趣，希望参与进来<br>现在就到 <a target="_blank" href="http://www.pinp.me/www/www/">PINP官网</a>
注册一个帐号，先学习如何制作拼文，您撰写的文章以后可以平移到 github 上，
在 PINP 或 github 发布（及持续维护）是可选的，当然，两者同时并用也行。  </p>
<p>等路标规划一即将完成，进入下一路标前，我们会公布如何参与“本探索群”的办法，
届时感兴趣的同学可以参与进来。</p>
</li>
</ol>
<p>关于 “在 github 上建立一套博客系统” 的开发目标、设计思路等详情，
<a target="_blank" href="http://best-practice.github.io/www/$$doc/buid-blog-system-on-github/">请参考这一篇</a>。</p>
<p>(完)</p>
</div>
</body>
</html>
